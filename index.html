<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Revisão Corrotinas & Room - FUNCIONA 100%</title>
  <style>
    body { font-family: Arial, sans-serif; background: #f0f2f5; margin: 0; padding: 20px; line-height: 1.6; }
    .container { max-width: 1000px; margin: 20px auto; background: white; padding: 30px; border-radius: 15px; box-shadow: 0 10px 30px rgba(0,0,0,0.1); }
    h1 { text-align: center; color: #4a148c; }
    .question { margin: 40px 0; padding: 25px; background: #f8f5ff; border-radius: 12px; border: 1px solid #e0e0e0; }
    .question h3 { color: #311b92; margin-top: 0; }
    .options label { display: block; padding: 15px; margin: 10px 0; background: #ede7f6; border-radius: 10px; cursor: pointer; transition: 0.3s; }
    .options label:hover { background: #d1c4e9; }
    .options input[type="radio"] { margin-right: 12px; transform: scale(1.4); }
    .btn { background: #6200ea; color: white; padding: 12px 25px; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; margin-top: 15px; }
    .btn:hover { background: #3700b3; }
    .feedback { margin-top: 15px; padding: 18px; border-radius: 10px; display: none; font-weight: bold; }
    .correct { background: #e8f5e9; border: 2px solid #4caf50; color: #2e7d32; }
    .incorrect { background: #ffebee; border: 2px solid #f44336; color: #c62828; }
    .score { text-align: center; font-size: 28px; font-weight: bold; padding: 20px; background: #ede7f6; border-radius: 12px; color: #4a148c; margin: 40px 0; }
  </style>
</head>
<body>
  <div class="container">
    <h1>Revisão Corrotinas & Room - P2</h1>
    <p style="text-align:center; color:#555;">Versão 100% funcional • Todas as explicações completas</p>

    <div id="quiz"></div>
    <div class="score" id="score">Acertos: 0 / 20</div>
  </div>

  <script>
    const questions = [
      { q: "1. Qual é a diferença fundamental entre launch e async?", options: ["a) async pode ser cancelado, mas launch não pode","b) launch é uma função suspend, enquanto async não é","c) launch é usado para fire and forget, async retorna resultado com await()","d) launch roda na main thread, async em background"], correct: 2, exp: "Correta: c)<br>a) Errado → ambos canceláveis<br>b) Errado → nenhum é suspend<br>d) Errado → depende do dispatcher" },
      { q: "2. Qual anotação define a classe principal do banco de dados no Room?", options: ["a) @Entity","b) @Dao","c) @Database","d) @Query"], correct: 2, exp: "Correta: c) @Database" },
      { q: "3. Principal função da palavra-chave suspend?", options: ["a) Retorna com cache","b) Permite pausar sem bloquear thread","c) Força UI Thread","d) Cria thread automática"], correct: 1, exp: "Correta: b)" },
      { q: "4. Qual dispatcher para I/O (Retrofit, Room)?", options: ["a) Contextual","b) Main","c) Default","d) IO"], correct: 3, exp: "Correta: d) Dispatchers.IO" },
      { q: "5. O que faz o @Dao?", options: ["a) Define tabela","b) Conecta banco","c) Converte JSON","d) Define métodos de acesso"], correct: 3, exp: "Correta: d)" },
      { q: "6. Vantagem do viewModelScope?", options: ["a) Força IO","b) Continua após app fechado","c) Aumenta prioridade","d) Cancela automaticamente"], correct: 3, exp: "Correta: d)" },
      { q: "7. Finalidade do Dispatchers.IO?", options: ["a) Operações que podem bloquear","b) Atualizar UI","c) Cálculos CPU","d) Cancelamento"], correct: 0, exp: "Correta: a)" },
      { q: "8. Qual anotação cria uma tabela?", options: ["a) @Database","b) @PrimaryKey","c) @Entity","d) @Dao"], correct: 2, exp: "Correta: c) @Entity" },
      { q: "9. Função do suspend?", options: ["a) Só em RoomDatabase","b) Pausar sem bloquear","c) Roda em background automático","d) Retorna Job"], correct: 1, exp: "Correta: b)" },
      { q: "10. O que é o DAO?", options: ["a) Uma linha de dados","b) API de acesso ao banco","c) Configura versão","d) Mapeia objetos"], correct: 1, exp: "Correta: b)" },
      { q: "11. Para que serve withContext()?", options: ["a) Nova corrotina","b) Novo scope","c) Delay","d) Trocar dispatcher temporariamente"], correct: 3, exp: "Correta: d)" },
      { q: "12. Quem conecta Entities e DAOs?", options: ["a) @Entity","b) @Database","c) @Dao","d) viewModelScope"], correct: 1, exp: "Correta: b) @Database" },
      { q: "13. @PrimaryKey serve para?", options: ["a) ID único","b) Não nulo","c) Chave estrangeira","d) Índice"], correct: 0, exp: "Correta: a)" },
      { q: "14. Corrotinas substituíram principalmente?", options: ["a) AsyncTask e callbacks","b) SQLite","c) MVVM","d) ORM"], correct: 0, exp: "Correta: a)" },
      { q: "15. Scope correto na ViewModel?", options: ["a) lifecycleScope","b) MainScope","c) GlobalScope","d) viewModelScope"], correct: 3, exp: "Correta: d)" },
      { q: "16. Conceito que substitui callbacks (professor aceitou)?", options: ["a) Services","b) Activities","c) Scopes","d) Fragments"], correct: 2, exp: "Correta: c) Scopes" },
      { q: "17. Objetivo principal das corrotinas no Android?", options: ["a) Não bloquear UI Thread","b) Gerenciar ciclo de vida","c) Substituir SQLite","d) Compilar mais rápido"], correct: 0, exp: "Correta: a)" },
      { q: "18. Onde pode chamar função suspend?", options: ["a) Qualquer lugar com IO","b) Dentro de outra suspend ou builder","c) Qualquer thread","d) Direto do main()"], correct: 1, exp: "Correta: b)" },
      { q: "19. Builder para fire and forget?", options: ["a) async()","b) launch()","c) runBlocking()","d) withContext()"], correct: 1, exp: "Correta: b) launch()" },
      { q: "20. No CoroutineContext, quem define a thread?", options: ["a) Job","b) Função suspend","c) Dispatcher","d) CoroutineScope"], correct: 2, exp: "Correta: c) Dispatcher" }
    ];

    let score = 0;
    const quiz = document.getElementById("quiz");

    questions.forEach((q, i) => {
      let html = `<div class="question"><h3>${q.q}</h3><div class="options">`;
      q.options.forEach((opt, j) => {
        html += `<label><input type="radio" name="q${i}" value="${j}"> ${opt}</label>`;
      });
      html += `</div><button class="btn" onclick="verificar(${i})">Verificar</button><div id="fb${i}" class="feedback"></div></div>`;
      quiz.innerHTML += html;
    });

    function verificar(i) {
      const selecionada = document.querySelector(`input[name="q${i}"]:checked`);
      const fb = document.getElementById(`fb${i}`);
      if (!selecionada) { fb.innerHTML = "Selecione uma opção!"; fb.className = "feedback incorrect"; fb.style.display = "block"; return; }
      const resp = parseInt(selecionada.value);
      if (resp === questions[i].correct) {
        fb.innerHTML = "Correta! " + questions[i].exp;
        fb.className = "feedback correct";
        score++;
      } else {
        fb.innerHTML = "Errada! " + questions[i].exp;
        fb.className = "feedback incorrect";
      }
      fb.style.display = "block";
      document.querySelectorAll(`input[name="q${i}"]`).forEach(r => r.disabled = true);
      document.getElementById("score").innerText = `Acertos: ${score} / 20`;
    }

    window.verificar = verificar; // torna a função global
  </script>
</body>
</html>
